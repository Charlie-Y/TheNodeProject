// Generated by CoffeeScript 1.7.1

/*

This will be the information architexture for the nodes etc..
not sure if this is necessary. maybe. I think that they can be used as 
entities and something else...

Yeha they will extend entities and collections. of course.... maybe
 */


/*

Template 

class ClassName 
     * === Class Properties === #
     * === Class Methods === #
     * ==== Constructor === #

    constructor: () ->

     * === Instance Properties === #
     * === Instance Methods === #

     * toString: () ->
 */

(function() {
  var NODE_PATH_RADIUS, NODE_RADIUS, PLAYER_RADIUS,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  NODE_RADIUS = 10;

  NODE_PATH_RADIUS = 5;

  PLAYER_RADIUS = 8;


  /*
  
  === NexusNode ===
  
  - a specific node in a graph of nodes. 
  - I think this is necessary. hmm. 
  - Does this need to be as botha n entity and the data structure?
   */

  ENGINE.NexusNode = (function(_super) {
    __extends(NexusNode, _super);

    function NexusNode(args) {
      this.getNeighbors = __bind(this.getNeighbors, this);
      NexusNode.__super__.constructor.call(this, args);
      this.paths = [];
    }

    NexusNode.prototype.nodeId = void 0;

    NexusNode.prototype.label = void 0;

    NexusNode.prototype.paths = [];

    NexusNode.prototype.toString = function() {
      return "(" + this.x + ", " + this.z + ") - " + this.index;
    };

    NexusNode.prototype.step = function(delta) {};

    NexusNode.prototype.render = function(delta) {
      var geometry, material, mesh;
      if (this.model == null) {
        geometry = new THREE.SphereGeometry(NODE_RADIUS, 32, 16);
        material = new THREE.MeshLambertMaterial({
          color: 0x2ecfca
        });
        mesh = new THREE.Mesh(geometry, material);
        this.model = mesh;
        this.label = ENGINE.HelperSprite.makeTextSprite(" " + this.index + " ");
        ENGINE.threeScene.add(this.label);
        ENGINE.threeScene.add(this.model);
      }
      return this.updateModelPosition();
    };

    NexusNode.prototype.updateModelPosition = function() {
      NexusNode.__super__.updateModelPosition.call(this);
      return this.label.position = this.model.position.clone();
    };

    NexusNode.prototype.getNeighbors = function() {
      var neighbors, path, _i, _len, _ref;
      neighbors = [];
      _ref = this.paths;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        path = _ref[_i];
        neighbors.push(path.otherNode(this));
      }
      return neighbors;
    };

    return NexusNode;

  })(ENGINE.Entity);


  /*
  
  === NexusPath ===
  - Connects two NexusNodes to each other
  - There can be things on the path on their way to a node
   */

  ENGINE.NexusPath = (function(_super) {
    __extends(NexusPath, _super);

    function NexusPath(args, nodeA, nodeB) {
      this.nodeA = nodeA;
      this.nodeB = nodeB;
      this.otherNode = __bind(this.otherNode, this);
      NexusPath.__super__.constructor.call(this, args);
      if (this.hasNodes()) {
        this.nodeA.paths.push(this);
        this.nodeB.paths.push(this);
      }
    }

    NexusPath.prototype.nodeA = void 0;

    NexusPath.prototype.nodeB = void 0;

    NexusPath.prototype.pathId = void 0;

    NexusPath.prototype.step = function(delta) {};

    NexusPath.prototype.render = function(delta) {
      var geometry, line, material;
      if (this.model == null) {
        material = new THREE.LineBasicMaterial({
          color: 0x0000ff
        });
        geometry = new THREE.Geometry();
        geometry.vertices.push(this.nodeA.positionFromData());
        geometry.vertices.push(this.nodeB.positionFromData());
        line = new THREE.Line(geometry, material);
        ENGINE.threeScene.add(line);
        this.model = line;
      }
      return this.updateModelPosition();
    };

    NexusPath.prototype.hasNodes = function() {
      return (this.nodeA != null) && (this.nodeB != null);
    };

    NexusPath.prototype.setModelPositionFromNodes = function() {
      var newPosA, newPosB;
      if (this.model != null) {
        newPosA = this.nodeA.positionFromData();
        newPosB = this.nodeB.positionFromData();
        if (!this.model.geometry.vertices[0].equals(newPosA)) {
          this.model.geometry.vertices[0] = newPosA;
          this.model.geometry.verticesNeedUpdate = true;
        }
        if (!this.model.geometry.vertices[1].equals(newPosB)) {
          this.model.geometry.vertices[1] = newPosB;
          return this.model.geometry.verticesNeedUpdate = true;
        }
      }
    };

    NexusPath.prototype.updateModelPosition = function() {
      return this.setModelPositionFromNodes();
    };

    NexusPath.prototype.otherNode = function(node) {
      if (this.nodeA === node) {
        return this.nodeB;
      }
      if (this.nodeB === node) {
        return this.nodeA;
      }
    };

    NexusPath.prototype.toString = function() {
      return this.nodeA.toString() + " - " + this.nodeB.toString();
    };

    return NexusPath;

  })(ENGINE.Entity);


  /* 
  
  === Nexon ===
  - # a nexon is an entity that inhabits a path or a node 
  - can be the main character
  - name still up for grabs. sounds like Nixon.
   */

  ENGINE.Nexon = (function(_super) {
    __extends(Nexon, _super);

    function Nexon(args) {
      this.onPath = __bind(this.onPath, this);
      this.onNode = __bind(this.onNode, this);
      this.updateModelPosition = __bind(this.updateModelPosition, this);
      this.render = __bind(this.render, this);
      this.step = __bind(this.step, this);
      Nexon.__super__.constructor.call(this, args);
    }

    Nexon.prototype.gridPos = void 0;

    Nexon.prototype.direction = void 0;

    Nexon.prototype.position = void 0;

    Nexon.prototype.label = void 0;

    Nexon.prototype.names = void 0;

    Nexon.prototype.health = void 0;

    Nexon.prototype.type = void 0;

    Nexon.prototype.step = function(delta) {};

    Nexon.prototype.render = function(delta) {
      var geometry, material, mesh;
      if (this.model == null) {
        geometry = new THREE.SphereGeometry(PLAYER_RADIUS, 32, 16);
        material = new THREE.MeshLambertMaterial({
          color: 0x880000
        });
        mesh = new THREE.Mesh(geometry, material);
        this.model = mesh;
        ENGINE.threeScene.add(this.model);
      }
      return this.updateModelPosition();
    };

    Nexon.prototype.updateModelPosition = function() {
      this.x = this.gridPos.x;
      this.y = this.gridPos.y + 10;
      this.z = this.gridPos.z;
      return Nexon.__super__.updateModelPosition.call(this);
    };

    Nexon.prototype.jumpToRandomNode = function(delta) {
      if (this.onNode()) {
        this.gridPos = _.sample(this.gridPos.getNeighbors());
      }
      return this.updateModelPosition();
    };

    Nexon.prototype.onNode = function() {
      return ENGINE.NexusNode.prototype.isPrototypeOf(this.gridPos);
    };

    Nexon.prototype.onPath = function() {
      return ENGINE.NexusPath.prototype.isPrototypeOf(this.gridPos);
    };

    return Nexon;

  })(ENGINE.Entity);


  /* 
  
  === NexusGrid ===
  - Paths and Nodes combined in a structure for better querying 
  - also holds players etc.
   */

  ENGINE.NexusGrid = (function(_super) {
    __extends(NexusGrid, _super);

    function NexusGrid(args) {
      var centerOnZero, index, newX, newY, newZ, newestNode, spacing, x, xDim, z, zDim, _i, _j, _k, _ref, _ref1, _ref2;
      NexusGrid.__super__.constructor.call(this, args);
      console.log("new NexusGrid");
      xDim = 4;
      zDim = 4;
      centerOnZero = function(val, max) {
        return val - ((max - 1) / 2);
      };
      spacing = 200;
      for (x = _i = 0, _ref = xDim - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (z = _j = 0, _ref1 = zDim - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; z = 0 <= _ref1 ? ++_j : --_j) {
          newX = centerOnZero(x, xDim) * spacing;
          newY = 100;
          newZ = centerOnZero(z, zDim) * spacing;
          newestNode = this.add(ENGINE.NexusNode, {
            x: newX,
            y: newY,
            z: newZ
          });
        }
      }
      for (index = _k = 0, _ref2 = this.length - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; index = 0 <= _ref2 ? ++_k : --_k) {
        if ((index + 1) % zDim > 0) {
          this.add(ENGINE.NexusPath, {
            nodeA: this[index],
            nodeB: this[index + 1]
          });
        }
        if (index <= (zDim * (xDim - 1) - 1)) {
          this.add(ENGINE.NexusPath, {
            nodeA: this[index],
            nodeB: this[index + zDim]
          });
        }
      }
      this.playerNexon = this.add(ENGINE.Nexon, {
        gridPos: this[0]
      });
    }

    NexusGrid.prototype.playerNexon = void 0;

    NexusGrid.prototype.getPathByNodes = function(nodeA, nodeB) {};

    NexusGrid.prototype.getNode = function(index) {};

    NexusGrid.prototype.getPath = function(index) {};

    NexusGrid.prototype.randomNode = function() {
      return this.add(ENGINE.NexusNode, {
        x: Math.round(Math.random() * 100),
        y: 30,
        z: Math.round(Math.random() * 300)
      });
    };

    return NexusGrid;

  })(ENGINE.Collection);

}).call(this);
